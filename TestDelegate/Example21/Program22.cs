using System;
//https://metanit.com/sharp/tutorial/3.43.php
//В прошлой теме подробно были рассмотрены делегаты.
//Однако данные примеры, возможно, не показывают истинной силы делегатов,
//так как нужные нам методы в данном случае мы можем вызвать и напрямую без всяких делегатов.
//Однако наиболее сильная сторона делегатов состоит в том, что они позволяют делегировать
//выполнение некоторому коду извне.
//И на момент написания программы мы можем не знать,
//что за код будет выполняться. Мы просто вызываем делегат.
//А какой метод будет непосредственно выполняться при вызове делегата, будет решаться потом.
//Например, наши классы будут распространяться в виде отдельной библиотеки классов,
//которая будет подключаться в проект другого разработчика.
//И этот разработчик захочет определить какую-то свою логику обработки,
//но изменить исходный код нашей библиотеки классов он не может.
//И делегаты как раз предоставляют возможность вызвать некое действие,
//которое задается извне и которое на момент написания кода может быть неизвестно.
namespace TestDelegate.Example21
{
//Теперь при снятии денег через метод Withdraw мы сначала проверяем,
//имеет ли делегат ссылку на какой-либо метод(иначе он имеет значение null).
//И если метод установлен, то вызываем его, передавая соответствующее сообщение в качестве параметра.
//Теперь протестируем класс в основной программе:

    public class Program22
    {
        public Program22()
        {
            // создаем банковский счет
            Account account = new Account(200);
            // Добавляем в делегат ссылку на метод Show_Message
            // а сам делегат передается в качестве параметра метода RegisterHandler
            //Таким образом, мы создали механизм обратного вызова для класса Account,
            //который срабатывает в случае снятия денег.
            //Поскольку делегат объявлен внутри класса Account,
            //то чтобы к нему получить доступ, используется выражение Account.AccountStateHandler.

            Account.AccountStateHandler colorDelegate = new Account.AccountStateHandler(Color_Message);
            //Хотя в примере наш делегат принимал адрес на один метод, в действительности он может указывать сразу на несколько методов.
            //Кроме того, при необходимости мы можем удалить ссылки на адреса определенных методов, чтобы они не вызывались при вызове делегата.

            account.RegisterHandler(new Account.AccountStateHandler(Show_Message));
            account.RegisterHandler(colorDelegate);
            // Два раза подряд пытаемся снять деньги
            account.Withdraw(100);
            account.Withdraw(150);
            // Удаляем делегат
            account.UnregisterHandler(colorDelegate);
            account.Withdraw(50);
            //Console.ReadLine();
        }

        //Опять же может возникнуть вопрос: почему бы в коде метода Withdraw() не выводить сообщение о снятии денег? Зачем нужно задействовать какой-то делегат?
        //Дело в том, что не всегда у нас есть доступ к коду классов.Например, часть классов может создаваться и компилироваться одним человеком,
        //который не будет знать, как эти классы будут использоваться.А использовать эти классы будет другой разработчик.
        //Так, здесь мы выводим сообщение на консоль. Однако для класса Account не важно, как это сообщение выводится.
        //Классу Account даже не известно, что вообще будет делаться в результате списания денег. Он просто посылает уведомление об этом через делегат.

        //В результате, если мы создаем консольное приложение, мы можем через делегат выводить сообщение на консоль.
        //Если мы создаем графическое приложение Windows Forms или WPF, то можно выводить сообщение в виде графического окна.
        //А можно не просто выводить сообщение. А, например, записать при списании информацию об этом действии в файл
        //или отправить уведомление на электронную почту.В общем любыми способами обработать вызов делегата.
        //И способ обработки не будет зависеть от класса Account.


        private static void Show_Message(String message)
        {
            Console.WriteLine(message);
        }
        //В целях тестирования мы создали еще один метод - Color_Message, который выводит то же самое сообщение только красным цветом.
        //Для первого делегата создается отдельная переменная. 
        private static void Color_Message(string message)
        {
            // Устанавливаем красный цвет символов
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(message);
            // Сбрасываем настройки цвета
            Console.ResetColor();
        }
    }
}
